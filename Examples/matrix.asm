; Generated by Lang compiler

extern GetCommandLineA
extern ExitProcess

section .code
global _start
_start:
    call GetCommandLineA
    mov rcx, rax
    call main
    mov ecx, eax
    call ExitProcess

extern puts

extern print_num

vector_init:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    movss DWORD [rbp + 24], xmm1 ; push arg 1 
    movss DWORD [rbp + 32], xmm2 ; push arg 2 
    movss DWORD [rbp + 40], xmm3 ; push arg 3 
    
    ; *vector.x = x
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbp + 24]
    movss DWORD [rbx], xmm5
    
    ; *vector.y = y
    mov rbx, QWORD [rbp + 16]
    add rbx, 4 ; member offset 'y'
    movss xmm5, DWORD [rbp + 32]
    movss DWORD [rbx], xmm5
    
    ; *vector.z = z
    mov rbx, QWORD [rbp + 16]
    add rbx, 8 ; member offset 'z'
    movss xmm5, DWORD [rbp + 40]
    movss DWORD [rbx], xmm5
    
    xor rax, rax ; Default return value 0
    L_function_vector_init_exit:
    mov rsp, rbp
    pop rbp
    ret
    

vector_dot:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    mov QWORD [rbp + 24], rdx ; push arg 1 
    
    ; return *a.x * *b.x + *a.y * *b.y + *a.z * *b.z
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'x'
    movss xmm4, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbx]
    mulss xmm4, xmm5
    mov rbx, QWORD [rbp + 16]
    add rbx, 4 ; member offset 'y'
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 4 ; member offset 'y'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    mov rbx, QWORD [rbp + 16]
    add rbx, 8 ; member offset 'z'
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 8 ; member offset 'z'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    movss xmm0, xmm4 ; return via xmm0
    jmp L_function_vector_dot_exit
    
    xor rax, rax ; Default return value 0
    L_function_vector_dot_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_identity:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    
    ; *matrix_index(matrix, 0, 0) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_0]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 0, 1) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_1]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 0, 2) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_2]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 0, 3) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_3]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 1, 0) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_4]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 1, 1) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_5]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 1, 2) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_6]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 1, 3) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_7]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 2, 0) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_8]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 2, 1) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_9]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 2, 2) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_10]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 2, 3) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_11]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 3, 0) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_12]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 3, 1) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_13]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 3, 2) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_14]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 3, 3) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_15]
    movss DWORD [rbx], xmm4
    
    xor rax, rax ; Default return value 0
    L_function_matrix_identity_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_translate:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    movss DWORD [rbp + 24], xmm1 ; push arg 1 
    movss DWORD [rbp + 32], xmm2 ; push arg 2 
    movss DWORD [rbp + 40], xmm3 ; push arg 3 
    
    ; *matrix_index(matrix, 0, 0) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_16]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 0, 1) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_17]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 0, 2) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_18]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 0, 3) = x
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbp + 24]
    movss DWORD [rbx], xmm5
    
    ; *matrix_index(matrix, 1, 0) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_19]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 1, 1) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_20]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 1, 2) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_21]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 1, 3) = y
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbp + 32]
    movss DWORD [rbx], xmm5
    
    ; *matrix_index(matrix, 2, 0) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_22]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 2, 1) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_23]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 2, 2) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_24]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 2, 3) = z
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbp + 40]
    movss DWORD [rbx], xmm5
    
    ; *matrix_index(matrix, 3, 0) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_25]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 3, 1) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_26]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 3, 2) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_27]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 3, 3) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_28]
    movss DWORD [rbx], xmm4
    
    xor rax, rax ; Default return value 0
    L_function_matrix_translate_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_scale:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    movss DWORD [rbp + 24], xmm1 ; push arg 1 
    movss DWORD [rbp + 32], xmm2 ; push arg 2 
    movss DWORD [rbp + 40], xmm3 ; push arg 3 
    
    ; matrix.cells[0] = x
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 0
    imul r10, 4
    add rbx, r10
    movss xmm5, DWORD [rbp + 24]
    movss DWORD [rbx], xmm5
    
    ; matrix.cells[1] = 0.000000f
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 1
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_29]
    movss DWORD [rbx], xmm4
    
    ; matrix.cells[2] = 0.000000f
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 2
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_30]
    movss DWORD [rbx], xmm4
    
    ; matrix.cells[3] = 0.000000f
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 3
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_31]
    movss DWORD [rbx], xmm4
    
    ; matrix.cells[4] = 0.000000f
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 4
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_32]
    movss DWORD [rbx], xmm4
    
    ; matrix.cells[5] = y
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 5
    imul r10, 4
    add rbx, r10
    movss xmm5, DWORD [rbp + 32]
    movss DWORD [rbx], xmm5
    
    ; matrix.cells[6] = 0.000000f
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 6
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_33]
    movss DWORD [rbx], xmm4
    
    ; matrix.cells[7] = 0.000000f
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 7
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_34]
    movss DWORD [rbx], xmm4
    
    ; matrix.cells[8] = 0.000000f
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 8
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_35]
    movss DWORD [rbx], xmm4
    
    ; matrix.cells[9] = 0.000000f
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 9
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_36]
    movss DWORD [rbx], xmm4
    
    ; matrix.cells[10] = z
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 10
    imul r10, 4
    add rbx, r10
    movss xmm5, DWORD [rbp + 40]
    movss DWORD [rbx], xmm5
    
    ; matrix.cells[11] = 0.000000f
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 11
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_37]
    movss DWORD [rbx], xmm4
    
    ; matrix.cells[12] = 0.000000f
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 12
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_38]
    movss DWORD [rbx], xmm4
    
    ; matrix.cells[13] = 0.000000f
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 13
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_39]
    movss DWORD [rbx], xmm4
    
    ; matrix.cells[14] = 0.000000f
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 14
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_40]
    movss DWORD [rbx], xmm4
    
    ; matrix.cells[15] = 1.000000f
    lea rbx, QWORD [rbp + 16] ; get address of 'matrix'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'cells'
    mov r10, 15
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_41]
    movss DWORD [rbx], xmm4
    
    xor rax, rax ; Default return value 0
    L_function_matrix_scale_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_index:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    mov DWORD [rbp + 24], edx ; push arg 1 
    mov DWORD [rbp + 32], r8d ; push arg 2 
    
    ; return &matrix.cells[i * 4 + j]
    movsx rbx, DWORD [rbp + 24]
    mov r10, 4
    imul rbx, r10
    movsx r10, DWORD [rbp + 32]
    add rbx, r10
    lea r10, QWORD [rbp + 16] ; get address of 'matrix'
    mov r10, QWORD [r10]
    add r10, 0 ; member offset 'cells'
    imul rbx, 4
    add r10, rbx
    mov rax, r10 ; return via rax
    jmp L_function_matrix_index_exit
    
    xor rax, rax ; Default return value 0
    L_function_matrix_index_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_multiply:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    mov QWORD [rbp + 24], rdx ; push arg 1 
    mov QWORD [rbp + 32], r8 ; push arg 2 
    sub rsp, 16 ; reserve stack space for 2 locals
    
    ; let i: i32;
    mov DWORD [rbp + -16], 0 ; zero initialize 'i'
    
    ; let j: i32;
    mov DWORD [rbp + -12], 0 ; zero initialize 'j'
    
    ; while (i < 4)
    L_loop0:
    movsx rbx, DWORD [rbp + -16]
    mov r10, 4
    cmp rbx, r10
    setl bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit0
        ; j = 0
        lea rbx, QWORD [rbp + -12] ; get address of 'j'
        mov r10, 0
        mov DWORD [rbx], r10d
        
        ; while (j < 4)
        L_loop1:
        movsx rbx, DWORD [rbp + -12]
        mov r10, 4
        cmp rbx, r10
        setl bl
        and bl, 1
        movzx rbx, bl
        cmp rbx, 0
        je L_exit1
            ; *matrix_index(result, i, j) = *matrix_index(a, i, 0) * *matrix_index(b, 0, j) + *matrix_index(a, i, 1) * *matrix_index(b, 1, j) + *matrix_index(a, i, 2) * *matrix_index(b, 2, j) + *matrix_index(a, i, 3) * *matrix_index(b, 3, j)
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 16]
            mov rcx, rbx ; arg 1
            movsx rbx, DWORD [rbp + -16]
            mov rdx, rbx ; arg 2
            mov rbx, 0
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm4, DWORD [rbx]
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 24]
            mov rcx, rbx ; arg 1
            mov rbx, 0
            mov rdx, rbx ; arg 2
            movsx rbx, DWORD [rbp + -12]
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm5, DWORD [rbx]
            mulss xmm4, xmm5
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 16]
            mov rcx, rbx ; arg 1
            movsx rbx, DWORD [rbp + -16]
            mov rdx, rbx ; arg 2
            mov rbx, 1
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm5, DWORD [rbx]
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 24]
            mov rcx, rbx ; arg 1
            mov rbx, 1
            mov rdx, rbx ; arg 2
            movsx rbx, DWORD [rbp + -12]
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm6, DWORD [rbx]
            mulss xmm5, xmm6
            addss xmm4, xmm5
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 16]
            mov rcx, rbx ; arg 1
            movsx rbx, DWORD [rbp + -16]
            mov rdx, rbx ; arg 2
            mov rbx, 2
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm5, DWORD [rbx]
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 24]
            mov rcx, rbx ; arg 1
            mov rbx, 2
            mov rdx, rbx ; arg 2
            movsx rbx, DWORD [rbp + -12]
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm6, DWORD [rbx]
            mulss xmm5, xmm6
            addss xmm4, xmm5
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 16]
            mov rcx, rbx ; arg 1
            movsx rbx, DWORD [rbp + -16]
            mov rdx, rbx ; arg 2
            mov rbx, 3
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm5, DWORD [rbx]
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 24]
            mov rcx, rbx ; arg 1
            mov rbx, 3
            mov rdx, rbx ; arg 2
            movsx rbx, DWORD [rbp + -12]
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm6, DWORD [rbx]
            mulss xmm5, xmm6
            addss xmm4, xmm5
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 32]
            mov rcx, rbx ; arg 1
            movsx rbx, DWORD [rbp + -16]
            mov rdx, rbx ; arg 2
            movsx rbx, DWORD [rbp + -12]
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss DWORD [rbx], xmm4
            
            ; j++
            lea rbx, QWORD [rbp + -12] ; get address of 'j'
            mov r10, rbx
            movsx rbx, DWORD [rbx]
            mov r11, rbx
            inc r11
            mov DWORD [r10], r11d
            
        jmp L_loop1
        L_exit1:
        
        ; i++
        lea rbx, QWORD [rbp + -16] ; get address of 'i'
        mov r10, rbx
        movsx rbx, DWORD [rbx]
        mov r11, rbx
        inc r11
        mov DWORD [r10], r11d
        
    jmp L_loop0
    L_exit0:
    
    xor rax, rax ; Default return value 0
    L_function_matrix_multiply_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_transform_position:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    mov QWORD [rbp + 24], rdx ; push arg 1 
    mov QWORD [rbp + 32], r8 ; push arg 2 
    
    ; result.x = *matrix_index(matrix, 0, 0) * vector.x + *matrix_index(matrix, 0, 1) * vector.y + *matrix_index(matrix, 0, 2) * vector.z + *matrix_index(matrix, 0, 3)
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbx]
    mulss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 4 ; member offset 'y'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 8 ; member offset 'z'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    addss xmm4, xmm5
    lea rbx, QWORD [rbp + 32] ; get address of 'result'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'x'
    movss DWORD [rbx], xmm4
    
    ; result.y = *matrix_index(matrix, 1, 0) * vector.x + *matrix_index(matrix, 1, 1) * vector.y + *matrix_index(matrix, 1, 2) * vector.z + *matrix_index(matrix, 1, 3)
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbx]
    mulss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 4 ; member offset 'y'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 8 ; member offset 'z'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    addss xmm4, xmm5
    lea rbx, QWORD [rbp + 32] ; get address of 'result'
    mov rbx, QWORD [rbx]
    add rbx, 4 ; member offset 'y'
    movss DWORD [rbx], xmm4
    
    ; result.z = *matrix_index(matrix, 2, 0) * vector.x + *matrix_index(matrix, 2, 1) * vector.y + *matrix_index(matrix, 2, 2) * vector.z + *matrix_index(matrix, 2, 3)
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbx]
    mulss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 4 ; member offset 'y'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 8 ; member offset 'z'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    addss xmm4, xmm5
    lea rbx, QWORD [rbp + 32] ; get address of 'result'
    mov rbx, QWORD [rbx]
    add rbx, 8 ; member offset 'z'
    movss DWORD [rbx], xmm4
    
    xor rax, rax ; Default return value 0
    L_function_matrix_transform_position_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_transform_direction:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    mov QWORD [rbp + 24], rdx ; push arg 1 
    mov QWORD [rbp + 32], r8 ; push arg 2 
    
    ; result.x = *matrix_index(matrix, 0, 0) * vector.x + *matrix_index(matrix, 0, 1) * vector.y + *matrix_index(matrix, 0, 2) * vector.z
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbx]
    mulss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 4 ; member offset 'y'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 8 ; member offset 'z'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    lea rbx, QWORD [rbp + 32] ; get address of 'result'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'x'
    movss DWORD [rbx], xmm4
    
    ; result.y = *matrix_index(matrix, 1, 0) * vector.x + *matrix_index(matrix, 1, 1) * vector.y + *matrix_index(matrix, 1, 2) * vector.z
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbx]
    mulss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 4 ; member offset 'y'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 8 ; member offset 'z'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    lea rbx, QWORD [rbp + 32] ; get address of 'result'
    mov rbx, QWORD [rbx]
    add rbx, 4 ; member offset 'y'
    movss DWORD [rbx], xmm4
    
    ; result.z = *matrix_index(matrix, 2, 0) * vector.x + *matrix_index(matrix, 2, 1) * vector.y + *matrix_index(matrix, 2, 2) * vector.z
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbx]
    mulss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 4 ; member offset 'y'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    lea rbx, QWORD [rbp + 24] ; get address of 'vector'
    mov rbx, QWORD [rbx]
    add rbx, 8 ; member offset 'z'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    lea rbx, QWORD [rbp + 32] ; get address of 'result'
    mov rbx, QWORD [rbx]
    add rbx, 8 ; member offset 'z'
    movss DWORD [rbx], xmm4
    
    xor rax, rax ; Default return value 0
    L_function_matrix_transform_direction_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_trace:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    sub rsp, 16 ; reserve stack space for 2 locals
    
    ; let trace: f32;
    mov DWORD [rbp + -16], 0 ; zero initialize 'trace'
    
    ; let i: i32;
    mov DWORD [rbp + -12], 0 ; zero initialize 'i'
    
    ; while (i < 4)
    L_loop2:
    movsx rbx, DWORD [rbp + -12]
    mov r10, 4
    cmp rbx, r10
    setl bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit2
        ; trace = trace + *matrix_index(matrix, i, i)
        sub rsp, 32 ; reserve shadow space and 3 arguments
        mov rbx, QWORD [rbp + 16]
        mov rcx, rbx ; arg 1
        movsx rbx, DWORD [rbp + -12]
        mov rdx, rbx ; arg 2
        movsx rbx, DWORD [rbp + -12]
        mov r8, rbx ; arg 3
        call matrix_index
        add rsp, 32 ; pop arguments
        mov rbx, rax ; get return value
        movss xmm4, DWORD [rbx]
        movss xmm6, DWORD [rbp + -16]
        addss xmm6, xmm4
        lea rbx, QWORD [rbp + -16] ; get address of 'trace'
        movss DWORD [rbx], xmm6
        
        ; i++
        lea rbx, QWORD [rbp + -12] ; get address of 'i'
        mov r10, rbx
        movsx rbx, DWORD [rbx]
        mov r11, rbx
        inc r11
        mov DWORD [r10], r11d
        
    jmp L_loop2
    L_exit2:
    
    ; return trace
    movss xmm5, DWORD [rbp + -16]
    movss xmm0, xmm5 ; return via xmm0
    jmp L_function_matrix_trace_exit
    
    xor rax, rax ; Default return value 0
    L_function_matrix_trace_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_print:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    sub rsp, 16 ; reserve stack space for 3 locals
    
    ; let i: i32;
    mov DWORD [rbp + -16], 0 ; zero initialize 'i'
    
    ; while (i < 4)
    L_loop3:
    movsx rbx, DWORD [rbp + -16]
    mov r10, 4
    cmp rbx, r10
    setl bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit3
        ; let j: i32;
        mov DWORD [rbp + -12], 0 ; zero initialize 'j'
        
        ; while (j < 4)
        L_loop4:
        movsx rbx, DWORD [rbp + -12]
        mov r10, 4
        cmp rbx, r10
        setl bl
        and bl, 1
        movzx rbx, bl
        cmp rbx, 0
        je L_exit4
            ; let num: i32; num = cast(i32) *matrix_index(matrix, i, j);
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 16]
            mov rcx, rbx ; arg 1
            movsx rbx, DWORD [rbp + -16]
            mov rdx, rbx ; arg 2
            movsx rbx, DWORD [rbp + -12]
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm4, DWORD [rbx]
            cvttss2si rbx, xmm4
            lea r10, QWORD [rbp + -8] ; get address of 'num'
            mov DWORD [r10], ebx
            
            ; print_num(num)
            sub rsp, 32 ; reserve shadow space and 1 arguments
            movsx rbx, DWORD [rbp + -8]
            mov rcx, rbx ; arg 1
            call print_num
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            
            ; puts(" ")
            sub rsp, 32 ; reserve shadow space and 1 arguments
            lea rbx, [REL lit_str_42]
            mov rcx, rbx ; arg 1
            call puts
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            
            ; j++
            lea rbx, QWORD [rbp + -12] ; get address of 'j'
            mov r10, rbx
            movsx rbx, DWORD [rbx]
            mov r11, rbx
            inc r11
            mov DWORD [r10], r11d
            
        jmp L_loop4
        L_exit4:
        
        ; puts("\n")
        sub rsp, 32 ; reserve shadow space and 1 arguments
        lea rbx, [REL lit_str_43]
        mov rcx, rbx ; arg 1
        call puts
        add rsp, 32 ; pop arguments
        mov rbx, rax ; get return value
        
        ; i++
        lea rbx, QWORD [rbp + -16] ; get address of 'i'
        mov r10, rbx
        movsx rbx, DWORD [rbx]
        mov r11, rbx
        inc r11
        mov DWORD [r10], r11d
        
    jmp L_loop3
    L_exit3:
    
    xor rax, rax ; Default return value 0
    L_function_matrix_print_exit:
    mov rsp, rbp
    pop rbp
    ret
    

main:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    sub rsp, 224 ; reserve stack space for 5 locals
    
    ; let a: Matrix4;
    lea rdi, QWORD [rbp + -224] ; zero initialize 'a'
    xor rax, rax
    mov ecx, 64
    rep stosb
    
    ; matrix_translate(&a, 2.000000f, 0.000000f, 1.000000f)
    sub rsp, 32 ; reserve shadow space and 4 arguments
    lea rbx, QWORD [rbp + -224] ; get address of 'a'
    mov rcx, rbx ; arg 1
    movss xmm4, DWORD [REL lit_flt_44]
    movss xmm1, xmm4 ; arg 2
    movss xmm4, DWORD [REL lit_flt_45]
    movss xmm2, xmm4 ; arg 3
    movss xmm4, DWORD [REL lit_flt_46]
    movss xmm3, xmm4 ; arg 4
    call matrix_translate
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; let b: Matrix4;
    lea rdi, QWORD [rbp + -160] ; zero initialize 'b'
    xor rax, rax
    mov ecx, 64
    rep stosb
    
    ; matrix_scale(&b, 2.000000f, 3.000000f, 4.000000f)
    sub rsp, 32 ; reserve shadow space and 4 arguments
    lea rbx, QWORD [rbp + -160] ; get address of 'b'
    mov rcx, rbx ; arg 1
    movss xmm4, DWORD [REL lit_flt_47]
    movss xmm1, xmm4 ; arg 2
    movss xmm4, DWORD [REL lit_flt_48]
    movss xmm2, xmm4 ; arg 3
    movss xmm4, DWORD [REL lit_flt_49]
    movss xmm3, xmm4 ; arg 4
    call matrix_scale
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; let c: Matrix4;
    lea rdi, QWORD [rbp + -96] ; zero initialize 'c'
    xor rax, rax
    mov ecx, 64
    rep stosb
    
    ; matrix_multiply(&a, &b, &c)
    sub rsp, 32 ; reserve shadow space and 3 arguments
    lea rbx, QWORD [rbp + -224] ; get address of 'a'
    mov rcx, rbx ; arg 1
    lea rbx, QWORD [rbp + -160] ; get address of 'b'
    mov rdx, rbx ; arg 2
    lea rbx, QWORD [rbp + -96] ; get address of 'c'
    mov r8, rbx ; arg 3
    call matrix_multiply
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; matrix_print(&c)
    sub rsp, 32 ; reserve shadow space and 1 arguments
    lea rbx, QWORD [rbp + -96] ; get address of 'c'
    mov rcx, rbx ; arg 1
    call matrix_print
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; let v: Vector3;
    lea rdi, QWORD [rbp + -32] ; zero initialize 'v'
    xor rax, rax
    mov ecx, 12
    rep stosb
    
    ; vector_init(&v, 3.000000f, 5.000000f, 6.000000f)
    sub rsp, 32 ; reserve shadow space and 4 arguments
    lea rbx, QWORD [rbp + -32] ; get address of 'v'
    mov rcx, rbx ; arg 1
    movss xmm4, DWORD [REL lit_flt_50]
    movss xmm1, xmm4 ; arg 2
    movss xmm4, DWORD [REL lit_flt_51]
    movss xmm2, xmm4 ; arg 3
    movss xmm4, DWORD [REL lit_flt_52]
    movss xmm3, xmm4 ; arg 4
    call vector_init
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; let result: Vector3;
    lea rdi, QWORD [rbp + -20] ; zero initialize 'result'
    xor rax, rax
    mov ecx, 12
    rep stosb
    
    ; matrix_transform_position(&c, &v, &result)
    sub rsp, 32 ; reserve shadow space and 3 arguments
    lea rbx, QWORD [rbp + -96] ; get address of 'c'
    mov rcx, rbx ; arg 1
    lea rbx, QWORD [rbp + -32] ; get address of 'v'
    mov rdx, rbx ; arg 2
    lea rbx, QWORD [rbp + -20] ; get address of 'result'
    mov r8, rbx ; arg 3
    call matrix_transform_position
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; return cast(i32) vector_dot(&v, &result)
    sub rsp, 32 ; reserve shadow space and 2 arguments
    lea rbx, QWORD [rbp + -32] ; get address of 'v'
    mov rcx, rbx ; arg 1
    lea rbx, QWORD [rbp + -20] ; get address of 'result'
    mov rdx, rbx ; arg 2
    call vector_dot
    add rsp, 32 ; pop arguments
    movss xmm4, xmm0 ; get return value (f32)
    cvttss2si rbx, xmm4
    mov rax, rbx ; return via rax
    jmp L_function_main_exit
    
    xor rax, rax ; Default return value 0
    L_function_main_exit:
    mov rsp, rbp
    pop rbp
    ret
    


section .data
lit_flt_0 dq 3f800000h ; 1.000000f
lit_flt_1 dq 0h ; 0.000000f
lit_flt_2 dq 0h ; 0.000000f
lit_flt_3 dq 0h ; 0.000000f
lit_flt_4 dq 0h ; 0.000000f
lit_flt_5 dq 3f800000h ; 1.000000f
lit_flt_6 dq 0h ; 0.000000f
lit_flt_7 dq 0h ; 0.000000f
lit_flt_8 dq 0h ; 0.000000f
lit_flt_9 dq 0h ; 0.000000f
lit_flt_10 dq 3f800000h ; 1.000000f
lit_flt_11 dq 0h ; 0.000000f
lit_flt_12 dq 0h ; 0.000000f
lit_flt_13 dq 0h ; 0.000000f
lit_flt_14 dq 0h ; 0.000000f
lit_flt_15 dq 3f800000h ; 1.000000f
lit_flt_16 dq 3f800000h ; 1.000000f
lit_flt_17 dq 0h ; 0.000000f
lit_flt_18 dq 0h ; 0.000000f
lit_flt_19 dq 0h ; 0.000000f
lit_flt_20 dq 3f800000h ; 1.000000f
lit_flt_21 dq 0h ; 0.000000f
lit_flt_22 dq 0h ; 0.000000f
lit_flt_23 dq 0h ; 0.000000f
lit_flt_24 dq 3f800000h ; 1.000000f
lit_flt_25 dq 0h ; 0.000000f
lit_flt_26 dq 0h ; 0.000000f
lit_flt_27 dq 0h ; 0.000000f
lit_flt_28 dq 3f800000h ; 1.000000f
lit_flt_29 dq 0h ; 0.000000f
lit_flt_30 dq 0h ; 0.000000f
lit_flt_31 dq 0h ; 0.000000f
lit_flt_32 dq 0h ; 0.000000f
lit_flt_33 dq 0h ; 0.000000f
lit_flt_34 dq 0h ; 0.000000f
lit_flt_35 dq 0h ; 0.000000f
lit_flt_36 dq 0h ; 0.000000f
lit_flt_37 dq 0h ; 0.000000f
lit_flt_38 dq 0h ; 0.000000f
lit_flt_39 dq 0h ; 0.000000f
lit_flt_40 dq 0h ; 0.000000f
lit_flt_41 dq 3f800000h ; 1.000000f
lit_str_42 db " ", 0
lit_str_43 db "", 0Ah, "", 0
lit_flt_44 dq 40000000h ; 2.000000f
lit_flt_45 dq 0h ; 0.000000f
lit_flt_46 dq 3f800000h ; 1.000000f
lit_flt_47 dq 40000000h ; 2.000000f
lit_flt_48 dq 40400000h ; 3.000000f
lit_flt_49 dq 40800000h ; 4.000000f
lit_flt_50 dq 40400000h ; 3.000000f
lit_flt_51 dq 40a00000h ; 5.000000f
lit_flt_52 dq 40c00000h ; 6.000000f

; Generated by Lang compiler

GLOBAL _start

extern GetCommandLineA
extern ExitProcess

SECTION .code
_start:
    call GetCommandLineA
    mov r10, rax
    xor rcx, rcx
    sub rsp, 8 * 64 ; Max 64 command line args
    mov rdx, rsp
    arg_loop_top:
    mov bl, BYTE [rax]
    test bl, bl
    jz arg_loop_exit
    cmp bl, ' '
    jne arg_loop_next
    cmp r10, rax
    je skip
    mov BYTE [rax], 0
    mov QWORD [rdx], r10
    add rdx, 8
    inc rcx
    skip:
    mov r10, rax
    inc r10
    arg_loop_next:
    inc rax
    jmp arg_loop_top
    arg_loop_exit:
    mov al, BYTE [r10]
    cmp al, ' '
    je args_done
    cmp al, 0
    je args_done
    mov QWORD [rdx], r10
    inc rcx
    args_done:
    mov rdx, rsp
    sub rsp, 32
    call main
    mov ecx, eax
    call ExitProcess

EXTERN GetStdHandle

EXTERN WriteFile

print:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    mov DWORD [rbp + 24], edx ; push arg 1 
    sub rsp, 16 ; reserve stack space for 2 locals
    
    ; let std_handle: void*; std_handle = GetStdHandle(-11);
    sub rsp, 32 ; reserve shadow space and 1 arguments
    mov rbx, -11
    mov rcx, rbx ; arg 1
    call GetStdHandle
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    lea r10, QWORD [rbp + -16] ; get address of 'std_handle'
    mov QWORD [r10], rbx
    
    ; let bytes_written: i32;
    mov DWORD [rbp + -8], 0 ; zero initialize 'bytes_written'
    
    ; WriteFile(std_handle, str, str_len, &bytes_written, 0)
    sub rsp, 48 ; reserve shadow space and 5 arguments
    mov rbx, QWORD [rbp + -16]
    mov rcx, rbx ; arg 1
    mov rbx, QWORD [rbp + 16]
    mov rdx, rbx ; arg 2
    movsx rbx, DWORD [rbp + 24]
    mov r8, rbx ; arg 3
    lea rbx, QWORD [rbp + -8] ; get address of 'bytes_written'
    mov r9, rbx ; arg 4
    mov rbx, 0
    mov DWORD [rsp + 32], ebx ; arg 5
    call WriteFile
    add rsp, 48 ; pop arguments
    mov rbx, rax ; get return value
    
    xor rax, rax ; Default return value 0
    L_function_print_exit:
    mov rsp, rbp
    pop rbp
    ret
    

print_num:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov DWORD [rbp + 16], ecx ; push arg 0 
    sub rsp, 32 ; reserve stack space for 5 locals
    
    ; let num_str: u8[8];
    mov QWORD [rbp + -32], 0 ; zero initialize 'num_str'
    
    ; let idx: i32; idx = 0;
    lea rbx, QWORD [rbp + -24] ; get address of 'idx'
    mov r10, 0
    mov DWORD [rbx], r10d
    
    ; if (num == 0)
    movsx rbx, DWORD [rbp + 16]
    mov r10, 0
    cmp rbx, r10
    sete bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit0
        ; print("0 ", 2)
        sub rsp, 32 ; reserve shadow space and 2 arguments
        lea rbx, [REL lit_str_0]
        mov rcx, rbx ; arg 1
        mov rbx, 2
        mov rdx, rbx ; arg 2
        call print
        add rsp, 32 ; pop arguments
        mov rbx, rax ; get return value
        
        ; return
        mov rax, 0
        jmp L_function_print_num_exit
        
    L_exit0:
    
    ; while (num > 0)
    L_loop1:
    movsx rbx, DWORD [rbp + 16]
    mov r10, 0
    cmp rbx, r10
    setg bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit1
        ; let digit: u8; digit = cast(u8) num % 10;
        movsx rbx, DWORD [rbp + 16]
        mov r10, 10
        mov rax, rbx
        cqo
        idiv r10
        mov rbx, rdx
        lea r10, QWORD [rbp + -20] ; get address of 'digit'
        mov BYTE [r10], bl
        
        ; num_str[idx] = digit + 48
        lea rbx, QWORD [rbp + -32] ; get address of 'num_str'
        movsx r10, DWORD [rbp + -24]
        imul r10, 1
        add rbx, r10
        movzx r10, BYTE [rbp + -20]
        mov r11, 48
        add r10, r11
        mov BYTE [rbx], r10b
        
        ; num = num / 10
        movsx rbx, DWORD [rbp + 16]
        mov r10, 10
        mov rax, rbx
        cqo
        idiv r10
        mov rbx, rax
        lea r10, QWORD [rbp + 16] ; get address of 'num'
        mov DWORD [r10], ebx
        
        ; idx = idx + 1
        movsx rbx, DWORD [rbp + -24]
        mov r10, 1
        add rbx, r10
        lea r10, QWORD [rbp + -24] ; get address of 'idx'
        mov DWORD [r10], ebx
        
    jmp L_loop1
    L_exit1:
    
    ; let i: i32; i = 0;
    lea rbx, QWORD [rbp + -16] ; get address of 'i'
    mov r10, 0
    mov DWORD [rbx], r10d
    
    ; while (i < idx / 2)
    L_loop2:
    movsx rbx, DWORD [rbp + -24]
    mov r10, 2
    mov rax, rbx
    cqo
    idiv r10
    mov rbx, rax
    movsx r10, DWORD [rbp + -16]
    cmp r10, rbx
    setl r10b
    and r10b, 1
    movzx r10, r10b
    cmp r10, 0
    je L_exit2
        ; let tmp: u8; tmp = num_str[i];
        lea rbx, QWORD [rbp + -32] ; get address of 'num_str'
        movsx r10, DWORD [rbp + -16]
        imul r10, 1
        add rbx, r10
        movzx rbx, BYTE [rbx]
        lea r10, QWORD [rbp + -12] ; get address of 'tmp'
        mov BYTE [r10], bl
        
        ; num_str[i] = num_str[idx - i - 1]
        movsx rbx, DWORD [rbp + -24]
        movsx r10, DWORD [rbp + -16]
        sub rbx, r10
        mov r10, 1
        sub rbx, r10
        lea r10, QWORD [rbp + -32] ; get address of 'num_str'
        imul rbx, 1
        add r10, rbx
        movzx r10, BYTE [r10]
        lea rbx, QWORD [rbp + -32] ; get address of 'num_str'
        movsx r11, DWORD [rbp + -16]
        imul r11, 1
        add rbx, r11
        mov BYTE [rbx], r10b
        
        ; num_str[idx - i - 1] = tmp
        lea rbx, QWORD [rbp + -24] ; get address of 'idx'
        lea r10, QWORD [rbp + -16] ; get address of 'i'
        sub rbx, r10
        mov r10, 1
        sub rbx, r10
        lea r10, QWORD [rbp + -32] ; get address of 'num_str'
        imul rbx, 1
        add r10, rbx
        movzx rbx, BYTE [rbp + -12]
        mov BYTE [r10], bl
        
        ; i++
        lea rbx, QWORD [rbp + -16] ; get address of 'i'
        mov r10, rbx
        movsx rbx, DWORD [rbx]
        mov r11, rbx
        inc r11
        mov DWORD [r10], r11d
        
    jmp L_loop2
    L_exit2:
    
    ; *(num_str + idx) = 32
    lea rbx, QWORD [rbp + -32] ; get address of 'num_str'
    movsx r10, DWORD [rbp + -24]
    add rbx, r10
    mov r10, 32
    mov BYTE [rbx], r10b
    
    ; print(num_str, idx + 1)
    sub rsp, 32 ; reserve shadow space and 2 arguments
    lea rbx, QWORD [rbp + -32] ; get address of 'num_str'
    mov rcx, rbx ; arg 1
    movsx rbx, DWORD [rbp + -24]
    mov r10, 1
    add rbx, r10
    mov rdx, rbx ; arg 2
    call print
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    xor rax, rax ; Default return value 0
    L_function_print_num_exit:
    mov rsp, rbp
    pop rbp
    ret
    

vector_init:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    movss DWORD [rbp + 24], xmm1 ; push arg 1 
    movss DWORD [rbp + 32], xmm2 ; push arg 2 
    movss DWORD [rbp + 40], xmm3 ; push arg 3 
    
    ; *vector.x = x
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbp + 24]
    movss DWORD [rbx], xmm5
    
    ; *vector.y = y
    mov rbx, QWORD [rbp + 16]
    add rbx, 4 ; member offset 'y'
    movss xmm5, DWORD [rbp + 32]
    movss DWORD [rbx], xmm5
    
    ; *vector.z = z
    mov rbx, QWORD [rbp + 16]
    add rbx, 8 ; member offset 'z'
    movss xmm5, DWORD [rbp + 40]
    movss DWORD [rbx], xmm5
    
    xor rax, rax ; Default return value 0
    L_function_vector_init_exit:
    mov rsp, rbp
    pop rbp
    ret
    

vector_dot:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    mov QWORD [rbp + 24], rdx ; push arg 1 
    
    ; return *a.x * *b.x + *a.y * *b.y + *a.z * *b.z
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'x'
    movss xmm4, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbx]
    mulss xmm4, xmm5
    mov rbx, QWORD [rbp + 16]
    add rbx, 4 ; member offset 'y'
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 4 ; member offset 'y'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    mov rbx, QWORD [rbp + 16]
    add rbx, 8 ; member offset 'z'
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 8 ; member offset 'z'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    movss xmm0, xmm4 ; return via xmm0
    jmp L_function_vector_dot_exit
    
    xor rax, rax ; Default return value 0
    L_function_vector_dot_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_identity:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    
    ; *matrix_index(matrix, 0, 0) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_1]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 0, 1) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_2]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 0, 2) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_3]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 0, 3) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_4]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 1, 0) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_5]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 1, 1) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_6]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 1, 2) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_7]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 1, 3) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_8]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 2, 0) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_9]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 2, 1) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_10]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 2, 2) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_11]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 2, 3) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_12]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 3, 0) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_13]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 3, 1) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_14]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 3, 2) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_15]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 3, 3) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_16]
    movss DWORD [rbx], xmm4
    
    xor rax, rax ; Default return value 0
    L_function_matrix_identity_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_translate:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    movss DWORD [rbp + 24], xmm1 ; push arg 1 
    movss DWORD [rbp + 32], xmm2 ; push arg 2 
    movss DWORD [rbp + 40], xmm3 ; push arg 3 
    
    ; *matrix_index(matrix, 0, 0) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_17]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 0, 1) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_18]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 0, 2) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_19]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 0, 3) = x
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbp + 24]
    movss DWORD [rbx], xmm5
    
    ; *matrix_index(matrix, 1, 0) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_20]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 1, 1) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_21]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 1, 2) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_22]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 1, 3) = y
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbp + 32]
    movss DWORD [rbx], xmm5
    
    ; *matrix_index(matrix, 2, 0) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_23]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 2, 1) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_24]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 2, 2) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_25]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 2, 3) = z
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbp + 40]
    movss DWORD [rbx], xmm5
    
    ; *matrix_index(matrix, 3, 0) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_26]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 3, 1) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_27]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 3, 2) = 0.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_28]
    movss DWORD [rbx], xmm4
    
    ; *matrix_index(matrix, 3, 3) = 1.000000f
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [REL lit_flt_29]
    movss DWORD [rbx], xmm4
    
    xor rax, rax ; Default return value 0
    L_function_matrix_translate_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_scale:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    movss DWORD [rbp + 24], xmm1 ; push arg 1 
    movss DWORD [rbp + 32], xmm2 ; push arg 2 
    movss DWORD [rbp + 40], xmm3 ; push arg 3 
    
    ; *matrix.cells[0] = x
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 0
    imul r10, 4
    add rbx, r10
    movss xmm5, DWORD [rbp + 24]
    movss DWORD [rbx], xmm5
    
    ; *matrix.cells[1] = 0.000000f
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 1
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_30]
    movss DWORD [rbx], xmm4
    
    ; *matrix.cells[2] = 0.000000f
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 2
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_31]
    movss DWORD [rbx], xmm4
    
    ; *matrix.cells[3] = 0.000000f
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 3
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_32]
    movss DWORD [rbx], xmm4
    
    ; *matrix.cells[4] = 0.000000f
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 4
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_33]
    movss DWORD [rbx], xmm4
    
    ; *matrix.cells[5] = y
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 5
    imul r10, 4
    add rbx, r10
    movss xmm5, DWORD [rbp + 32]
    movss DWORD [rbx], xmm5
    
    ; *matrix.cells[6] = 0.000000f
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 6
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_34]
    movss DWORD [rbx], xmm4
    
    ; *matrix.cells[7] = 0.000000f
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 7
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_35]
    movss DWORD [rbx], xmm4
    
    ; *matrix.cells[8] = 0.000000f
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 8
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_36]
    movss DWORD [rbx], xmm4
    
    ; *matrix.cells[9] = 0.000000f
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 9
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_37]
    movss DWORD [rbx], xmm4
    
    ; *matrix.cells[10] = z
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 10
    imul r10, 4
    add rbx, r10
    movss xmm5, DWORD [rbp + 40]
    movss DWORD [rbx], xmm5
    
    ; *matrix.cells[11] = 0.000000f
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 11
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_38]
    movss DWORD [rbx], xmm4
    
    ; *matrix.cells[12] = 0.000000f
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 12
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_39]
    movss DWORD [rbx], xmm4
    
    ; *matrix.cells[13] = 0.000000f
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 13
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_40]
    movss DWORD [rbx], xmm4
    
    ; *matrix.cells[14] = 0.000000f
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 14
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_41]
    movss DWORD [rbx], xmm4
    
    ; *matrix.cells[15] = 1.000000f
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    mov r10, 15
    imul r10, 4
    add rbx, r10
    movss xmm4, DWORD [REL lit_flt_42]
    movss DWORD [rbx], xmm4
    
    xor rax, rax ; Default return value 0
    L_function_matrix_scale_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_index:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    mov DWORD [rbp + 24], edx ; push arg 1 
    mov DWORD [rbp + 32], r8d ; push arg 2 
    
    ; return &*matrix.cells[i * 4 + j]
    mov rbx, QWORD [rbp + 16]
    add rbx, 0 ; member offset 'cells'
    movsx r10, DWORD [rbp + 24]
    mov r11, 4
    imul r10, r11
    movsx r11, DWORD [rbp + 32]
    add r10, r11
    imul r10, 4
    add rbx, r10
    mov rax, rbx ; return via rax
    jmp L_function_matrix_index_exit
    
    xor rax, rax ; Default return value 0
    L_function_matrix_index_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_multiply:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    mov QWORD [rbp + 24], rdx ; push arg 1 
    mov QWORD [rbp + 32], r8 ; push arg 2 
    sub rsp, 16 ; reserve stack space for 2 locals
    
    ; let i: i32;
    mov DWORD [rbp + -16], 0 ; zero initialize 'i'
    
    ; let j: i32;
    mov DWORD [rbp + -12], 0 ; zero initialize 'j'
    
    ; while (i < 4)
    L_loop3:
    movsx rbx, DWORD [rbp + -16]
    mov r10, 4
    cmp rbx, r10
    setl bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit3
        ; j = 0
        lea rbx, QWORD [rbp + -12] ; get address of 'j'
        mov r10, 0
        mov DWORD [rbx], r10d
        
        ; while (j < 4)
        L_loop4:
        movsx rbx, DWORD [rbp + -12]
        mov r10, 4
        cmp rbx, r10
        setl bl
        and bl, 1
        movzx rbx, bl
        cmp rbx, 0
        je L_exit4
            ; *matrix_index(result, i, j) = *matrix_index(a, i, 0) * *matrix_index(b, 0, j) + *matrix_index(a, i, 1) * *matrix_index(b, 1, j) + *matrix_index(a, i, 2) * *matrix_index(b, 2, j) + *matrix_index(a, i, 3) * *matrix_index(b, 3, j)
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 16]
            mov rcx, rbx ; arg 1
            movsx rbx, DWORD [rbp + -16]
            mov rdx, rbx ; arg 2
            mov rbx, 0
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm4, DWORD [rbx]
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 24]
            mov rcx, rbx ; arg 1
            mov rbx, 0
            mov rdx, rbx ; arg 2
            movsx rbx, DWORD [rbp + -12]
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm5, DWORD [rbx]
            mulss xmm4, xmm5
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 16]
            mov rcx, rbx ; arg 1
            movsx rbx, DWORD [rbp + -16]
            mov rdx, rbx ; arg 2
            mov rbx, 1
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm5, DWORD [rbx]
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 24]
            mov rcx, rbx ; arg 1
            mov rbx, 1
            mov rdx, rbx ; arg 2
            movsx rbx, DWORD [rbp + -12]
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm6, DWORD [rbx]
            mulss xmm5, xmm6
            addss xmm4, xmm5
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 16]
            mov rcx, rbx ; arg 1
            movsx rbx, DWORD [rbp + -16]
            mov rdx, rbx ; arg 2
            mov rbx, 2
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm5, DWORD [rbx]
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 24]
            mov rcx, rbx ; arg 1
            mov rbx, 2
            mov rdx, rbx ; arg 2
            movsx rbx, DWORD [rbp + -12]
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm6, DWORD [rbx]
            mulss xmm5, xmm6
            addss xmm4, xmm5
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 16]
            mov rcx, rbx ; arg 1
            movsx rbx, DWORD [rbp + -16]
            mov rdx, rbx ; arg 2
            mov rbx, 3
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm5, DWORD [rbx]
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 24]
            mov rcx, rbx ; arg 1
            mov rbx, 3
            mov rdx, rbx ; arg 2
            movsx rbx, DWORD [rbp + -12]
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm6, DWORD [rbx]
            mulss xmm5, xmm6
            addss xmm4, xmm5
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 32]
            mov rcx, rbx ; arg 1
            movsx rbx, DWORD [rbp + -16]
            mov rdx, rbx ; arg 2
            movsx rbx, DWORD [rbp + -12]
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss DWORD [rbx], xmm4
            
            ; j++
            lea rbx, QWORD [rbp + -12] ; get address of 'j'
            mov r10, rbx
            movsx rbx, DWORD [rbx]
            mov r11, rbx
            inc r11
            mov DWORD [r10], r11d
            
        jmp L_loop4
        L_exit4:
        
        ; i++
        lea rbx, QWORD [rbp + -16] ; get address of 'i'
        mov r10, rbx
        movsx rbx, DWORD [rbx]
        mov r11, rbx
        inc r11
        mov DWORD [r10], r11d
        
    jmp L_loop3
    L_exit3:
    
    xor rax, rax ; Default return value 0
    L_function_matrix_multiply_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_transform_position:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    mov QWORD [rbp + 24], rdx ; push arg 1 
    mov QWORD [rbp + 32], r8 ; push arg 2 
    
    ; *result.x = *matrix_index(matrix, 0, 0) * *vector.x + *matrix_index(matrix, 0, 1) * *vector.y + *matrix_index(matrix, 0, 2) * *vector.z + *matrix_index(matrix, 0, 3)
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbx]
    mulss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 4 ; member offset 'y'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 8 ; member offset 'z'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    addss xmm4, xmm5
    mov rbx, QWORD [rbp + 32]
    add rbx, 0 ; member offset 'x'
    movss DWORD [rbx], xmm4
    
    ; *result.y = *matrix_index(matrix, 1, 0) * *vector.x + *matrix_index(matrix, 1, 1) * *vector.y + *matrix_index(matrix, 1, 2) * *vector.z + *matrix_index(matrix, 1, 3)
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbx]
    mulss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 4 ; member offset 'y'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 8 ; member offset 'z'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    addss xmm4, xmm5
    mov rbx, QWORD [rbp + 32]
    add rbx, 4 ; member offset 'y'
    movss DWORD [rbx], xmm4
    
    ; *result.z = *matrix_index(matrix, 2, 0) * *vector.x + *matrix_index(matrix, 2, 1) * *vector.y + *matrix_index(matrix, 2, 2) * *vector.z + *matrix_index(matrix, 2, 3)
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbx]
    mulss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 4 ; member offset 'y'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 8 ; member offset 'z'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 3
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    addss xmm4, xmm5
    mov rbx, QWORD [rbp + 32]
    add rbx, 8 ; member offset 'z'
    movss DWORD [rbx], xmm4
    
    xor rax, rax ; Default return value 0
    L_function_matrix_transform_position_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_transform_direction:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    mov QWORD [rbp + 24], rdx ; push arg 1 
    mov QWORD [rbp + 32], r8 ; push arg 2 
    
    ; *result.x = *matrix_index(matrix, 0, 0) * *vector.x + *matrix_index(matrix, 0, 1) * *vector.y + *matrix_index(matrix, 0, 2) * *vector.z
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbx]
    mulss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 4 ; member offset 'y'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 8 ; member offset 'z'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    mov rbx, QWORD [rbp + 32]
    add rbx, 0 ; member offset 'x'
    movss DWORD [rbx], xmm4
    
    ; *result.y = *matrix_index(matrix, 1, 0) * *vector.x + *matrix_index(matrix, 1, 1) * *vector.y + *matrix_index(matrix, 1, 2) * *vector.z
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbx]
    mulss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 4 ; member offset 'y'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 8 ; member offset 'z'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    mov rbx, QWORD [rbp + 32]
    add rbx, 4 ; member offset 'y'
    movss DWORD [rbx], xmm4
    
    ; *result.z = *matrix_index(matrix, 2, 0) * *vector.x + *matrix_index(matrix, 2, 1) * *vector.y + *matrix_index(matrix, 2, 2) * *vector.z
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 0
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm4, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 0 ; member offset 'x'
    movss xmm5, DWORD [rbx]
    mulss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 1
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 4 ; member offset 'y'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    sub rsp, 32 ; reserve shadow space and 3 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    mov rbx, 2
    mov r8, rbx ; arg 3
    call matrix_index
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    movss xmm5, DWORD [rbx]
    mov rbx, QWORD [rbp + 24]
    add rbx, 8 ; member offset 'z'
    movss xmm6, DWORD [rbx]
    mulss xmm5, xmm6
    addss xmm4, xmm5
    mov rbx, QWORD [rbp + 32]
    add rbx, 8 ; member offset 'z'
    movss DWORD [rbx], xmm4
    
    xor rax, rax ; Default return value 0
    L_function_matrix_transform_direction_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_trace:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    sub rsp, 16 ; reserve stack space for 2 locals
    
    ; let trace: f32;
    mov DWORD [rbp + -16], 0 ; zero initialize 'trace'
    
    ; let i: i32;
    mov DWORD [rbp + -12], 0 ; zero initialize 'i'
    
    ; while (i < 4)
    L_loop5:
    movsx rbx, DWORD [rbp + -12]
    mov r10, 4
    cmp rbx, r10
    setl bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit5
        ; trace = trace + *matrix_index(matrix, i, i)
        sub rsp, 32 ; reserve shadow space and 3 arguments
        mov rbx, QWORD [rbp + 16]
        mov rcx, rbx ; arg 1
        movsx rbx, DWORD [rbp + -12]
        mov rdx, rbx ; arg 2
        movsx rbx, DWORD [rbp + -12]
        mov r8, rbx ; arg 3
        call matrix_index
        add rsp, 32 ; pop arguments
        mov rbx, rax ; get return value
        movss xmm4, DWORD [rbx]
        movss xmm6, DWORD [rbp + -16]
        addss xmm6, xmm4
        lea rbx, QWORD [rbp + -16] ; get address of 'trace'
        movss DWORD [rbx], xmm6
        
        ; i++
        lea rbx, QWORD [rbp + -12] ; get address of 'i'
        mov r10, rbx
        movsx rbx, DWORD [rbx]
        mov r11, rbx
        inc r11
        mov DWORD [r10], r11d
        
    jmp L_loop5
    L_exit5:
    
    ; return trace
    movss xmm5, DWORD [rbp + -16]
    movss xmm0, xmm5 ; return via xmm0
    jmp L_function_matrix_trace_exit
    
    xor rax, rax ; Default return value 0
    L_function_matrix_trace_exit:
    mov rsp, rbp
    pop rbp
    ret
    

matrix_print:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    sub rsp, 32 ; reserve stack space for 4 locals
    
    ; let i: i32;
    mov DWORD [rbp + -32], 0 ; zero initialize 'i'
    
    ; while (i < 4)
    L_loop6:
    movsx rbx, DWORD [rbp + -32]
    mov r10, 4
    cmp rbx, r10
    setl bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit6
        ; let j: i32;
        mov DWORD [rbp + -28], 0 ; zero initialize 'j'
        
        ; while (j < 4)
        L_loop7:
        movsx rbx, DWORD [rbp + -28]
        mov r10, 4
        cmp rbx, r10
        setl bl
        and bl, 1
        movzx rbx, bl
        cmp rbx, 0
        je L_exit7
            ; let num: i32; num = cast(i32) *matrix_index(matrix, i, j);
            sub rsp, 32 ; reserve shadow space and 3 arguments
            mov rbx, QWORD [rbp + 16]
            mov rcx, rbx ; arg 1
            movsx rbx, DWORD [rbp + -32]
            mov rdx, rbx ; arg 2
            movsx rbx, DWORD [rbp + -28]
            mov r8, rbx ; arg 3
            call matrix_index
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            movss xmm4, DWORD [rbx]
            cvttss2si rbx, xmm4
            lea r10, QWORD [rbp + -24] ; get address of 'num'
            mov DWORD [r10], ebx
            
            ; print_num(num)
            sub rsp, 32 ; reserve shadow space and 1 arguments
            movsx rbx, DWORD [rbp + -24]
            mov rcx, rbx ; arg 1
            call print_num
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            
            ; j++
            lea rbx, QWORD [rbp + -28] ; get address of 'j'
            mov r10, rbx
            movsx rbx, DWORD [rbx]
            mov r11, rbx
            inc r11
            mov DWORD [r10], r11d
            
        jmp L_loop7
        L_exit7:
        
        ; let newline: u8*; newline = "\n";
        lea rbx, QWORD [rbp + -16] ; get address of 'newline'
        lea r10, [REL lit_str_43]
        mov QWORD [rbx], r10
        
        ; print(newline, 1)
        sub rsp, 32 ; reserve shadow space and 2 arguments
        mov rbx, QWORD [rbp + -16]
        mov rcx, rbx ; arg 1
        mov rbx, 1
        mov rdx, rbx ; arg 2
        call print
        add rsp, 32 ; pop arguments
        mov rbx, rax ; get return value
        
        ; i++
        lea rbx, QWORD [rbp + -32] ; get address of 'i'
        mov r10, rbx
        movsx rbx, DWORD [rbx]
        mov r11, rbx
        inc r11
        mov DWORD [r10], r11d
        
    jmp L_loop6
    L_exit6:
    
    xor rax, rax ; Default return value 0
    L_function_matrix_print_exit:
    mov rsp, rbp
    pop rbp
    ret
    

main:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    sub rsp, 224 ; reserve stack space for 5 locals
    
    ; let a: Matrix4;
    lea rdi, QWORD [rbp + -224] ; zero initialize 'a'
    xor rax, rax
    mov ecx, 64
    rep stosb
    
    ; matrix_translate(&a, 2.000000f, 0.000000f, 1.000000f)
    sub rsp, 32 ; reserve shadow space and 4 arguments
    lea rbx, QWORD [rbp + -224] ; get address of 'a'
    mov rcx, rbx ; arg 1
    movss xmm4, DWORD [REL lit_flt_44]
    movss xmm1, xmm4 ; arg 2
    movss xmm4, DWORD [REL lit_flt_45]
    movss xmm2, xmm4 ; arg 3
    movss xmm4, DWORD [REL lit_flt_46]
    movss xmm3, xmm4 ; arg 4
    call matrix_translate
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; let b: Matrix4;
    lea rdi, QWORD [rbp + -160] ; zero initialize 'b'
    xor rax, rax
    mov ecx, 64
    rep stosb
    
    ; matrix_scale(&b, 2.000000f, 3.000000f, 4.000000f)
    sub rsp, 32 ; reserve shadow space and 4 arguments
    lea rbx, QWORD [rbp + -160] ; get address of 'b'
    mov rcx, rbx ; arg 1
    movss xmm4, DWORD [REL lit_flt_47]
    movss xmm1, xmm4 ; arg 2
    movss xmm4, DWORD [REL lit_flt_48]
    movss xmm2, xmm4 ; arg 3
    movss xmm4, DWORD [REL lit_flt_49]
    movss xmm3, xmm4 ; arg 4
    call matrix_scale
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; let c: Matrix4;
    lea rdi, QWORD [rbp + -96] ; zero initialize 'c'
    xor rax, rax
    mov ecx, 64
    rep stosb
    
    ; matrix_multiply(&a, &b, &c)
    sub rsp, 32 ; reserve shadow space and 3 arguments
    lea rbx, QWORD [rbp + -224] ; get address of 'a'
    mov rcx, rbx ; arg 1
    lea rbx, QWORD [rbp + -160] ; get address of 'b'
    mov rdx, rbx ; arg 2
    lea rbx, QWORD [rbp + -96] ; get address of 'c'
    mov r8, rbx ; arg 3
    call matrix_multiply
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; matrix_print(&c)
    sub rsp, 32 ; reserve shadow space and 1 arguments
    lea rbx, QWORD [rbp + -96] ; get address of 'c'
    mov rcx, rbx ; arg 1
    call matrix_print
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; let v: Vector3;
    lea rdi, QWORD [rbp + -32] ; zero initialize 'v'
    xor rax, rax
    mov ecx, 12
    rep stosb
    
    ; vector_init(&v, 3.000000f, 5.000000f, 6.000000f)
    sub rsp, 32 ; reserve shadow space and 4 arguments
    lea rbx, QWORD [rbp + -32] ; get address of 'v'
    mov rcx, rbx ; arg 1
    movss xmm4, DWORD [REL lit_flt_50]
    movss xmm1, xmm4 ; arg 2
    movss xmm4, DWORD [REL lit_flt_51]
    movss xmm2, xmm4 ; arg 3
    movss xmm4, DWORD [REL lit_flt_52]
    movss xmm3, xmm4 ; arg 4
    call vector_init
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; let result: Vector3;
    lea rdi, QWORD [rbp + -20] ; zero initialize 'result'
    xor rax, rax
    mov ecx, 12
    rep stosb
    
    ; matrix_transform_position(&c, &v, &result)
    sub rsp, 32 ; reserve shadow space and 3 arguments
    lea rbx, QWORD [rbp + -96] ; get address of 'c'
    mov rcx, rbx ; arg 1
    lea rbx, QWORD [rbp + -32] ; get address of 'v'
    mov rdx, rbx ; arg 2
    lea rbx, QWORD [rbp + -20] ; get address of 'result'
    mov r8, rbx ; arg 3
    call matrix_transform_position
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; return cast(i32) vector_dot(&v, &result)
    sub rsp, 32 ; reserve shadow space and 2 arguments
    lea rbx, QWORD [rbp + -32] ; get address of 'v'
    mov rcx, rbx ; arg 1
    lea rbx, QWORD [rbp + -20] ; get address of 'result'
    mov rdx, rbx ; arg 2
    call vector_dot
    add rsp, 32 ; pop arguments
    movss xmm4, xmm0 ; get return value (f32)
    cvttss2si rbx, xmm4
    mov rax, rbx ; return via rax
    jmp L_function_main_exit
    
    xor rax, rax ; Default return value 0
    L_function_main_exit:
    mov rsp, rbp
    pop rbp
    ret
    


SECTION .data
lit_str_0 db "0 ", 0
lit_flt_1 dq 3f800000h ; 1.000000f
lit_flt_2 dq 0h ; 0.000000f
lit_flt_3 dq 0h ; 0.000000f
lit_flt_4 dq 0h ; 0.000000f
lit_flt_5 dq 0h ; 0.000000f
lit_flt_6 dq 3f800000h ; 1.000000f
lit_flt_7 dq 0h ; 0.000000f
lit_flt_8 dq 0h ; 0.000000f
lit_flt_9 dq 0h ; 0.000000f
lit_flt_10 dq 0h ; 0.000000f
lit_flt_11 dq 3f800000h ; 1.000000f
lit_flt_12 dq 0h ; 0.000000f
lit_flt_13 dq 0h ; 0.000000f
lit_flt_14 dq 0h ; 0.000000f
lit_flt_15 dq 0h ; 0.000000f
lit_flt_16 dq 3f800000h ; 1.000000f
lit_flt_17 dq 3f800000h ; 1.000000f
lit_flt_18 dq 0h ; 0.000000f
lit_flt_19 dq 0h ; 0.000000f
lit_flt_20 dq 0h ; 0.000000f
lit_flt_21 dq 3f800000h ; 1.000000f
lit_flt_22 dq 0h ; 0.000000f
lit_flt_23 dq 0h ; 0.000000f
lit_flt_24 dq 0h ; 0.000000f
lit_flt_25 dq 3f800000h ; 1.000000f
lit_flt_26 dq 0h ; 0.000000f
lit_flt_27 dq 0h ; 0.000000f
lit_flt_28 dq 0h ; 0.000000f
lit_flt_29 dq 3f800000h ; 1.000000f
lit_flt_30 dq 0h ; 0.000000f
lit_flt_31 dq 0h ; 0.000000f
lit_flt_32 dq 0h ; 0.000000f
lit_flt_33 dq 0h ; 0.000000f
lit_flt_34 dq 0h ; 0.000000f
lit_flt_35 dq 0h ; 0.000000f
lit_flt_36 dq 0h ; 0.000000f
lit_flt_37 dq 0h ; 0.000000f
lit_flt_38 dq 0h ; 0.000000f
lit_flt_39 dq 0h ; 0.000000f
lit_flt_40 dq 0h ; 0.000000f
lit_flt_41 dq 0h ; 0.000000f
lit_flt_42 dq 3f800000h ; 1.000000f
lit_str_43 db "", 0Ah, "", 0
lit_flt_44 dq 40000000h ; 2.000000f
lit_flt_45 dq 0h ; 0.000000f
lit_flt_46 dq 3f800000h ; 1.000000f
lit_flt_47 dq 40000000h ; 2.000000f
lit_flt_48 dq 40400000h ; 3.000000f
lit_flt_49 dq 40800000h ; 4.000000f
lit_flt_50 dq 40400000h ; 3.000000f
lit_flt_51 dq 40a00000h ; 5.000000f
lit_flt_52 dq 40c00000h ; 6.000000f

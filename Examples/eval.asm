; Generated by Lang compiler

extern GetCommandLineA
extern ExitProcess

section .code
global _start
_start:
    call GetCommandLineA
    mov rcx, rax
    call main
    mov ecx, eax
    call ExitProcess

extern exit

extern puts

skip_space:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    
    ; while (**cur == ' ')
    L_loop0:
    mov rbx, QWORD [rbp + 16]
    mov rbx, QWORD [rbx]
    movzx rbx, BYTE [rbx]
    mov r10, 32
    cmp rbx, r10
    sete bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit0
        ; (*cur)++
        mov rbx, QWORD [rbp + 16]
        mov r10, rbx
        mov rbx, QWORD [rbx]
        mov r11, rbx
        inc r11
        mov QWORD [r10], r11
        
    jmp L_loop0
    L_exit0:
    
    xor rax, rax ; Default return value 0
    L_function_skip_space_exit:
    mov rsp, rbp
    pop rbp
    ret
    

is_digit:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov BYTE [rbp + 16], cl ; push arg 0 
    
    ; return c >= '0' && c <= '9'
    movzx rbx, BYTE [rbp + 16]
    mov r10, 48
    cmp rbx, r10
    setge bl
    and bl, 1
    movzx rbx, bl
    test rbx, rbx
    je L_land_false_1 ; short circuit '&&'
    movzx r10, BYTE [rbp + 16]
    mov r11, 57
    cmp r10, r11
    setle r10b
    and r10b, 1
    movzx r10, r10b
    test r10, r10
    je L_land_false_1
    mov rbx, 1
    jmp L_land_exit_1
    L_land_false_1:
    mov rbx, 0
    L_land_exit_1:
    mov rax, rbx ; return via rax
    jmp L_function_is_digit_exit
    
    xor rax, rax ; Default return value 0
    L_function_is_digit_exit:
    mov rsp, rbp
    pop rbp
    ret
    

parse_expr_base:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    sub rsp, 16 ; reserve stack space for 3 locals
    
    ; skip_space(cur)
    sub rsp, 32 ; reserve shadow space and 1 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    call skip_space
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; let c: u8; c = **cur;
    mov rbx, QWORD [rbp + 16]
    mov rbx, QWORD [rbx]
    movzx rbx, BYTE [rbx]
    lea r10, QWORD [rbp + -16] ; get address of 'c'
    mov BYTE [r10], bl
    
    ; if (is_digit(c))
    sub rsp, 32 ; reserve shadow space and 1 arguments
    movzx rbx, BYTE [rbp + -16]
    mov rcx, rbx ; arg 1
    call is_digit
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    cmp rbx, 0
    ; else
    je L_else2
        ; let num: u32; num = 0;
        lea rbx, QWORD [rbp + -12] ; get address of 'num'
        mov r10, 0
        mov DWORD [rbx], r10d
        
        ; while (is_digit(c))
        L_loop3:
        sub rsp, 32 ; reserve shadow space and 1 arguments
        movzx rbx, BYTE [rbp + -16]
        mov rcx, rbx ; arg 1
        call is_digit
        add rsp, 32 ; pop arguments
        mov rbx, rax ; get return value
        cmp rbx, 0
        je L_exit3
            ; num = num * 10 + c - '0'
            mov ebx, DWORD [rbp + -12]
            mov r10, 10
            imul rbx, r10
            movzx r10, BYTE [rbp + -16]
            mov r11, 48
            sub r10, r11
            add rbx, r10
            lea r10, QWORD [rbp + -12] ; get address of 'num'
            mov DWORD [r10], ebx
            
            ; (*cur)++
            mov rbx, QWORD [rbp + 16]
            mov r10, rbx
            mov rbx, QWORD [rbx]
            mov r11, rbx
            inc r11
            mov QWORD [r10], r11
            
            ; c = **cur
            mov rbx, QWORD [rbp + 16]
            mov rbx, QWORD [rbx]
            movzx rbx, BYTE [rbx]
            lea r10, QWORD [rbp + -16] ; get address of 'c'
            mov BYTE [r10], bl
            
        jmp L_loop3
        L_exit3:
        
        ; return num
        mov ebx, DWORD [rbp + -12]
        mov rax, rbx ; return via rax
        jmp L_function_parse_expr_base_exit
        
    jmp L_exit2
    L_else2:
        ; if (c == '(')
        movzx rbx, BYTE [rbp + -16]
        mov r10, 40
        cmp rbx, r10
        sete bl
        and bl, 1
        movzx rbx, bl
        cmp rbx, 0
        ; else
        je L_else4
            ; (*cur)++
            mov rbx, QWORD [rbp + 16]
            mov r10, rbx
            mov rbx, QWORD [rbx]
            mov r11, rbx
            inc r11
            mov QWORD [r10], r11
            
            ; let expr: i32; expr = parse_expr(cur);
            sub rsp, 32 ; reserve shadow space and 1 arguments
            mov rbx, QWORD [rbp + 16]
            mov rcx, rbx ; arg 1
            call parse_expr
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            lea r10, QWORD [rbp + -8] ; get address of 'expr'
            mov DWORD [r10], ebx
            
            ; skip_space(cur)
            sub rsp, 32 ; reserve shadow space and 1 arguments
            mov rbx, QWORD [rbp + 16]
            mov rcx, rbx ; arg 1
            call skip_space
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            
            ; (*cur)++
            mov rbx, QWORD [rbp + 16]
            mov r10, rbx
            mov rbx, QWORD [rbx]
            mov r11, rbx
            inc r11
            mov QWORD [r10], r11
            
            ; return expr
            movsx rbx, DWORD [rbp + -8]
            mov rax, rbx ; return via rax
            jmp L_function_parse_expr_base_exit
            
        jmp L_exit4
        L_else4:
            ; puts("ERROR")
            sub rsp, 32 ; reserve shadow space and 1 arguments
            lea rbx, [REL lit_str_0]
            mov rcx, rbx ; arg 1
            call puts
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            
            ; exit(0)
            sub rsp, 32 ; reserve shadow space and 1 arguments
            mov rbx, 0
            mov rcx, rbx ; arg 1
            call exit
            add rsp, 32 ; pop arguments
            mov rbx, rax ; get return value
            
        L_exit4:
        
    L_exit2:
    
    xor rax, rax ; Default return value 0
    L_function_parse_expr_base_exit:
    mov rsp, rbp
    pop rbp
    ret
    

parse_expr_mul:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    sub rsp, 16 ; reserve stack space for 2 locals
    
    ; let lhs: i32; lhs = parse_expr_base(cur);
    sub rsp, 32 ; reserve shadow space and 1 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    call parse_expr_base
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    lea r10, QWORD [rbp + -16] ; get address of 'lhs'
    mov DWORD [r10], ebx
    
    ; skip_space(cur)
    sub rsp, 32 ; reserve shadow space and 1 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    call skip_space
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; while (**cur == '*')
    L_loop5:
    mov rbx, QWORD [rbp + 16]
    mov rbx, QWORD [rbx]
    movzx rbx, BYTE [rbx]
    mov r10, 42
    cmp rbx, r10
    sete bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit5
        ; (*cur)++
        mov rbx, QWORD [rbp + 16]
        mov r10, rbx
        mov rbx, QWORD [rbx]
        mov r11, rbx
        inc r11
        mov QWORD [r10], r11
        
        ; let rhs: i32; rhs = parse_expr_base(cur);
        sub rsp, 32 ; reserve shadow space and 1 arguments
        mov rbx, QWORD [rbp + 16]
        mov rcx, rbx ; arg 1
        call parse_expr_base
        add rsp, 32 ; pop arguments
        mov rbx, rax ; get return value
        lea r10, QWORD [rbp + -12] ; get address of 'rhs'
        mov DWORD [r10], ebx
        
        ; skip_space(cur)
        sub rsp, 32 ; reserve shadow space and 1 arguments
        mov rbx, QWORD [rbp + 16]
        mov rcx, rbx ; arg 1
        call skip_space
        add rsp, 32 ; pop arguments
        mov rbx, rax ; get return value
        
        ; lhs = lhs * rhs
        movsx rbx, DWORD [rbp + -16]
        movsx r10, DWORD [rbp + -12]
        imul rbx, r10
        lea r10, QWORD [rbp + -16] ; get address of 'lhs'
        mov DWORD [r10], ebx
        
    jmp L_loop5
    L_exit5:
    
    ; return lhs
    movsx rbx, DWORD [rbp + -16]
    mov rax, rbx ; return via rax
    jmp L_function_parse_expr_mul_exit
    
    xor rax, rax ; Default return value 0
    L_function_parse_expr_mul_exit:
    mov rsp, rbp
    pop rbp
    ret
    

parse_expr_add:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    sub rsp, 16 ; reserve stack space for 2 locals
    
    ; let lhs: i32; lhs = parse_expr_mul(cur);
    sub rsp, 32 ; reserve shadow space and 1 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    call parse_expr_mul
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    lea r10, QWORD [rbp + -16] ; get address of 'lhs'
    mov DWORD [r10], ebx
    
    ; skip_space(cur)
    sub rsp, 32 ; reserve shadow space and 1 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    call skip_space
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; while (**cur == '+')
    L_loop6:
    mov rbx, QWORD [rbp + 16]
    mov rbx, QWORD [rbx]
    movzx rbx, BYTE [rbx]
    mov r10, 43
    cmp rbx, r10
    sete bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit6
        ; (*cur)++
        mov rbx, QWORD [rbp + 16]
        mov r10, rbx
        mov rbx, QWORD [rbx]
        mov r11, rbx
        inc r11
        mov QWORD [r10], r11
        
        ; let rhs: i32; rhs = parse_expr_mul(cur);
        sub rsp, 32 ; reserve shadow space and 1 arguments
        mov rbx, QWORD [rbp + 16]
        mov rcx, rbx ; arg 1
        call parse_expr_mul
        add rsp, 32 ; pop arguments
        mov rbx, rax ; get return value
        lea r10, QWORD [rbp + -12] ; get address of 'rhs'
        mov DWORD [r10], ebx
        
        ; skip_space(cur)
        sub rsp, 32 ; reserve shadow space and 1 arguments
        mov rbx, QWORD [rbp + 16]
        mov rcx, rbx ; arg 1
        call skip_space
        add rsp, 32 ; pop arguments
        mov rbx, rax ; get return value
        
        ; lhs = lhs + rhs
        movsx rbx, DWORD [rbp + -16]
        movsx r10, DWORD [rbp + -12]
        add rbx, r10
        lea r10, QWORD [rbp + -16] ; get address of 'lhs'
        mov DWORD [r10], ebx
        
    jmp L_loop6
    L_exit6:
    
    ; return lhs
    movsx rbx, DWORD [rbp + -16]
    mov rax, rbx ; return via rax
    jmp L_function_parse_expr_add_exit
    
    xor rax, rax ; Default return value 0
    L_function_parse_expr_add_exit:
    mov rsp, rbp
    pop rbp
    ret
    

parse_expr:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    
    ; return parse_expr_add(cur)
    sub rsp, 32 ; reserve shadow space and 1 arguments
    mov rbx, QWORD [rbp + 16]
    mov rcx, rbx ; arg 1
    call parse_expr_add
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    mov rax, rbx ; return via rax
    jmp L_function_parse_expr_exit
    
    xor rax, rax ; Default return value 0
    L_function_parse_expr_exit:
    mov rsp, rbp
    pop rbp
    ret
    

main:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    sub rsp, 16 ; reserve stack space for 2 locals
    
    ; let cur: u8*; cur = arg;
    lea rbx, QWORD [rbp + -16] ; get address of 'cur'
    mov r10, QWORD [rbp + 16]
    mov QWORD [rbx], r10
    
    ; while (*cur++ != ' ')
    L_loop7:
    lea rbx, QWORD [rbp + -16] ; get address of 'cur'
    mov r10, rbx
    mov rbx, QWORD [rbx]
    mov r11, rbx
    inc r11
    mov QWORD [r10], r11
    movzx rbx, BYTE [rbx]
    mov r10, 32
    cmp rbx, r10
    setne bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit7
    jmp L_loop7
    L_exit7:
    
    ; let result: i32; result = parse_expr(&cur);
    sub rsp, 32 ; reserve shadow space and 1 arguments
    lea rbx, QWORD [rbp + -16] ; get address of 'cur'
    mov rcx, rbx ; arg 1
    call parse_expr
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    lea r10, QWORD [rbp + -8] ; get address of 'result'
    mov DWORD [r10], ebx
    
    ; return result
    movsx rbx, DWORD [rbp + -8]
    mov rax, rbx ; return via rax
    jmp L_function_main_exit
    
    xor rax, rax ; Default return value 0
    L_function_main_exit:
    mov rsp, rbp
    pop rbp
    ret
    


section .data
lit_str_0 db "ERROR", 0

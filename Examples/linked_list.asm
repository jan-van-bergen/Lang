; Generated by Lang compiler

extern GetCommandLineA
extern ExitProcess

section .code
global _start
_start:
    call GetCommandLineA
    mov r10, rax
    xor rcx, rcx
    sub rsp, 8 * 64 ; Max 64 command line args
    mov rdx, rsp
    arg_loop_top:
    mov bl, BYTE [rax]
    test bl, bl
    jz arg_loop_exit
    cmp bl, ' '
    jne arg_loop_next
    cmp r10, rax
    je skip
    mov BYTE [rax], 0
    mov QWORD [rdx], r10
    add rdx, 8
    inc rcx
    skip:
    mov r10, rax
    inc r10
    arg_loop_next:
    inc rax
    jmp arg_loop_top
    arg_loop_exit:
    mov al, BYTE [r10]
    cmp al, ' '
    je args_done
    cmp al, 0
    je args_done
    mov QWORD [rdx], r10
    inc rcx
    args_done:
    mov rdx, rsp
    sub rsp, 32
    call main
    mov ecx, eax
    call ExitProcess

extern malloc

extern free

list_make_elem:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov DWORD [rbp + 16], ecx ; push arg 0 
    sub rsp, 16 ; reserve stack space for 1 locals
    
    ; let elem: Linked_List*; elem = cast(Linked_List*) malloc(sizeof(Linked_List));
    sub rsp, 32 ; reserve shadow space and 1 arguments
    mov rbx, 16 ; sizeof 'Linked_List'
    mov rcx, rbx ; arg 1
    call malloc
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    lea r10, QWORD [rbp + -16] ; get address of 'elem'
    mov QWORD [r10], rbx
    
    ; elem.value = value
    lea rbx, QWORD [rbp + -16] ; get address of 'elem'
    mov rbx, QWORD [rbx]
    add rbx, 0 ; member offset 'value'
    movsx r10, DWORD [rbp + 16]
    mov DWORD [rbx], r10d
    
    ; elem.next = null
    lea rbx, QWORD [rbp + -16] ; get address of 'elem'
    mov rbx, QWORD [rbx]
    add rbx, 8 ; member offset 'next'
    mov r10, 0
    mov QWORD [rbx], r10
    
    ; return elem
    mov rbx, QWORD [rbp + -16]
    mov rax, rbx ; return via rax
    jmp L_function_list_make_elem_exit
    
    xor rax, rax ; Default return value 0
    L_function_list_make_elem_exit:
    mov rsp, rbp
    pop rbp
    ret
    

list_append:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    mov DWORD [rbp + 24], edx ; push arg 1 
    sub rsp, 16 ; reserve stack space for 1 locals
    
    ; let elem: Linked_List*; elem = list_make_elem(value);
    sub rsp, 32 ; reserve shadow space and 1 arguments
    movsx rbx, DWORD [rbp + 24]
    mov rcx, rbx ; arg 1
    call list_make_elem
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    lea r10, QWORD [rbp + -16] ; get address of 'elem'
    mov QWORD [r10], rbx
    
    ; if (list != null)
    mov rbx, QWORD [rbp + 16]
    mov r10, 0
    cmp rbx, r10
    setne bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit0
        ; while (list.next != null)
        L_loop1:
        lea rbx, QWORD [rbp + 16] ; get address of 'list'
        mov rbx, QWORD [rbx]
        add rbx, 8 ; member offset 'next'
        mov rbx, QWORD [rbx]
        mov r10, 0
        cmp rbx, r10
        setne bl
        and bl, 1
        movzx rbx, bl
        cmp rbx, 0
        je L_exit1
            ; list = list.next
            lea rbx, QWORD [rbp + 16] ; get address of 'list'
            mov rbx, QWORD [rbx]
            add rbx, 8 ; member offset 'next'
            mov rbx, QWORD [rbx]
            lea r10, QWORD [rbp + 16] ; get address of 'list'
            mov QWORD [r10], rbx
            
        jmp L_loop1
        L_exit1:
        
        ; list.next = elem
        lea rbx, QWORD [rbp + 16] ; get address of 'list'
        mov rbx, QWORD [rbx]
        add rbx, 8 ; member offset 'next'
        mov r10, QWORD [rbp + -16]
        mov QWORD [rbx], r10
        
    L_exit0:
    
    ; return elem
    mov rbx, QWORD [rbp + -16]
    mov rax, rbx ; return via rax
    jmp L_function_list_append_exit
    
    xor rax, rax ; Default return value 0
    L_function_list_append_exit:
    mov rsp, rbp
    pop rbp
    ret
    

list_delete:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    mov DWORD [rbp + 24], edx ; push arg 1 
    sub rsp, 16 ; reserve stack space for 2 locals
    
    ; if (list == null)
    mov rbx, QWORD [rbp + 16]
    mov r10, 0
    cmp rbx, r10
    sete bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit2
        ; return false
        mov rbx, 0
        mov rax, rbx ; return via rax
        jmp L_function_list_delete_exit
        
    L_exit2:
    
    ; let curr: Linked_List*; curr = list;
    lea rbx, QWORD [rbp + -16] ; get address of 'curr'
    mov r10, QWORD [rbp + 16]
    mov QWORD [rbx], r10
    
    ; let next: Linked_List*; next = curr.next;
    lea rbx, QWORD [rbp + -16] ; get address of 'curr'
    mov rbx, QWORD [rbx]
    add rbx, 8 ; member offset 'next'
    mov rbx, QWORD [rbx]
    lea r10, QWORD [rbp + -8] ; get address of 'next'
    mov QWORD [r10], rbx
    
    ; while (true)
    L_loop3:
    mov rbx, 1
    cmp rbx, 0
    je L_exit3
        ; if (next == null)
        mov rbx, QWORD [rbp + -8]
        mov r10, 0
        cmp rbx, r10
        sete bl
        and bl, 1
        movzx rbx, bl
        cmp rbx, 0
        je L_exit4
            ; return false
            mov rbx, 0
            mov rax, rbx ; return via rax
            jmp L_function_list_delete_exit
            
        L_exit4:
        
        ; if (next.value == value)
        lea rbx, QWORD [rbp + -8] ; get address of 'next'
        mov rbx, QWORD [rbx]
        add rbx, 0 ; member offset 'value'
        movsx rbx, DWORD [rbx]
        movsx r10, DWORD [rbp + 24]
        cmp rbx, r10
        sete bl
        and bl, 1
        movzx rbx, bl
        cmp rbx, 0
        je L_exit5
            ; break
            jmp L_exit3
            
        L_exit5:
        
        ; curr = next
        lea rbx, QWORD [rbp + -16] ; get address of 'curr'
        mov r10, QWORD [rbp + -8]
        mov QWORD [rbx], r10
        
        ; next = next.next
        lea rbx, QWORD [rbp + -8] ; get address of 'next'
        mov rbx, QWORD [rbx]
        add rbx, 8 ; member offset 'next'
        mov rbx, QWORD [rbx]
        lea r10, QWORD [rbp + -8] ; get address of 'next'
        mov QWORD [r10], rbx
        
    jmp L_loop3
    L_exit3:
    
    ; curr.next = next.next
    lea rbx, QWORD [rbp + -16] ; get address of 'curr'
    mov rbx, QWORD [rbx]
    add rbx, 8 ; member offset 'next'
    lea r10, QWORD [rbp + -8] ; get address of 'next'
    mov r10, QWORD [r10]
    add r10, 8 ; member offset 'next'
    mov r10, QWORD [r10]
    mov QWORD [rbx], r10
    
    ; free(next)
    sub rsp, 32 ; reserve shadow space and 1 arguments
    mov rbx, QWORD [rbp + -8]
    mov rcx, rbx ; arg 1
    call free
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; return true
    mov rbx, 1
    mov rax, rbx ; return via rax
    jmp L_function_list_delete_exit
    
    xor rax, rax ; Default return value 0
    L_function_list_delete_exit:
    mov rsp, rbp
    pop rbp
    ret
    

list_length:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    sub rsp, 16 ; reserve stack space for 1 locals
    
    ; if (list == null)
    mov rbx, QWORD [rbp + 16]
    mov r10, 0
    cmp rbx, r10
    sete bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit6
        ; return 0
        mov rbx, 0
        mov rax, rbx ; return via rax
        jmp L_function_list_length_exit
        
    L_exit6:
    
    ; let length: u32; length = 1;
    lea rbx, QWORD [rbp + -16] ; get address of 'length'
    mov r10, 1
    mov DWORD [rbx], r10d
    
    ; while (list.next != null)
    L_loop7:
    lea rbx, QWORD [rbp + 16] ; get address of 'list'
    mov rbx, QWORD [rbx]
    add rbx, 8 ; member offset 'next'
    mov rbx, QWORD [rbx]
    mov r10, 0
    cmp rbx, r10
    setne bl
    and bl, 1
    movzx rbx, bl
    cmp rbx, 0
    je L_exit7
        ; list = list.next
        lea rbx, QWORD [rbp + 16] ; get address of 'list'
        mov rbx, QWORD [rbx]
        add rbx, 8 ; member offset 'next'
        mov rbx, QWORD [rbx]
        lea r10, QWORD [rbp + 16] ; get address of 'list'
        mov QWORD [r10], rbx
        
        ; length++
        lea rbx, QWORD [rbp + -16] ; get address of 'length'
        mov r10, rbx
        mov ebx, DWORD [rbx]
        mov r11, rbx
        inc r11
        mov DWORD [r10], r11d
        
    jmp L_loop7
    L_exit7:
    
    ; return length
    mov ebx, DWORD [rbp + -16]
    mov rax, rbx ; return via rax
    jmp L_function_list_length_exit
    
    xor rax, rax ; Default return value 0
    L_function_list_length_exit:
    mov rsp, rbp
    pop rbp
    ret
    

main:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    sub rsp, 16 ; reserve stack space for 1 locals
    
    ; let head: Linked_List*; head = list_make_elem(3);
    sub rsp, 32 ; reserve shadow space and 1 arguments
    mov rbx, 3
    mov rcx, rbx ; arg 1
    call list_make_elem
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    lea r10, QWORD [rbp + -16] ; get address of 'head'
    mov QWORD [r10], rbx
    
    ; list_append(head, 2)
    sub rsp, 32 ; reserve shadow space and 2 arguments
    mov rbx, QWORD [rbp + -16]
    mov rcx, rbx ; arg 1
    mov rbx, 2
    mov rdx, rbx ; arg 2
    call list_append
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; list_append(head, 1)
    sub rsp, 32 ; reserve shadow space and 2 arguments
    mov rbx, QWORD [rbp + -16]
    mov rcx, rbx ; arg 1
    mov rbx, 1
    mov rdx, rbx ; arg 2
    call list_append
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; list_append(head, 0)
    sub rsp, 32 ; reserve shadow space and 2 arguments
    mov rbx, QWORD [rbp + -16]
    mov rcx, rbx ; arg 1
    mov rbx, 0
    mov rdx, rbx ; arg 2
    call list_append
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; list_append(head, 9)
    sub rsp, 32 ; reserve shadow space and 2 arguments
    mov rbx, QWORD [rbp + -16]
    mov rcx, rbx ; arg 1
    mov rbx, 9
    mov rdx, rbx ; arg 2
    call list_append
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; list_append(head, 8)
    sub rsp, 32 ; reserve shadow space and 2 arguments
    mov rbx, QWORD [rbp + -16]
    mov rcx, rbx ; arg 1
    mov rbx, 8
    mov rdx, rbx ; arg 2
    call list_append
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; list_append(head, 7)
    sub rsp, 32 ; reserve shadow space and 2 arguments
    mov rbx, QWORD [rbp + -16]
    mov rcx, rbx ; arg 1
    mov rbx, 7
    mov rdx, rbx ; arg 2
    call list_append
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; list_append(head, 6)
    sub rsp, 32 ; reserve shadow space and 2 arguments
    mov rbx, QWORD [rbp + -16]
    mov rcx, rbx ; arg 1
    mov rbx, 6
    mov rdx, rbx ; arg 2
    call list_append
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; list_append(head, 5)
    sub rsp, 32 ; reserve shadow space and 2 arguments
    mov rbx, QWORD [rbp + -16]
    mov rcx, rbx ; arg 1
    mov rbx, 5
    mov rdx, rbx ; arg 2
    call list_append
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; list_append(head, 4)
    sub rsp, 32 ; reserve shadow space and 2 arguments
    mov rbx, QWORD [rbp + -16]
    mov rcx, rbx ; arg 1
    mov rbx, 4
    mov rdx, rbx ; arg 2
    call list_append
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; list_append(head, 3)
    sub rsp, 32 ; reserve shadow space and 2 arguments
    mov rbx, QWORD [rbp + -16]
    mov rcx, rbx ; arg 1
    mov rbx, 3
    mov rdx, rbx ; arg 2
    call list_append
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; list_delete(head, 8)
    sub rsp, 32 ; reserve shadow space and 2 arguments
    mov rbx, QWORD [rbp + -16]
    mov rcx, rbx ; arg 1
    mov rbx, 8
    mov rdx, rbx ; arg 2
    call list_delete
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    
    ; return list_length(head)
    sub rsp, 32 ; reserve shadow space and 1 arguments
    mov rbx, QWORD [rbp + -16]
    mov rcx, rbx ; arg 1
    call list_length
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    mov rax, rbx ; return via rax
    jmp L_function_main_exit
    
    xor rax, rax ; Default return value 0
    L_function_main_exit:
    mov rsp, rbp
    pop rbp
    ret
    


section .data

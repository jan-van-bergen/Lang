; Generated by Lang compiler

extern GetCommandLineA
extern ExitProcess

section .code
global _start
_start:
    call GetCommandLineA
    mov rcx, rax
    call main
    mov ecx, eax
    call ExitProcess

extern GetStdHandle

extern WriteFile

extern strlen

; let STD_OUTPUT_HANDLE: i32; STD_OUTPUT_HANDLE = -11;

main:
    push rbp ; save RBP
    mov rbp, rsp ; stack frame
    mov QWORD [rbp + 16], rcx ; push arg 0 
    sub rsp, 48 ; reserve stack space for 5 locals
    
    ; let std_handle: void*; std_handle = GetStdHandle(STD_OUTPUT_HANDLE);
    sub rsp, 32 ; reserve shadow space and 1 arguments
    movsx rbx, DWORD [REL STD_OUTPUT_HANDLE]
    mov rcx, rbx ; arg 1
    call GetStdHandle
    add rsp, 32 ; pop arguments
    mov rbx, rax ; get return value
    lea r10, QWORD [rbp + -48] ; get address of 'std_handle'
    mov QWORD [r10], rbx
    
    ; let arg_count: u32; arg_count = 0;
    lea rbx, QWORD [rbp + -40] ; get address of 'arg_count'
    mov r10, 0
    mov DWORD [rbx], r10d
    
    ; let start: u8*; start = arg;
    lea rbx, QWORD [rbp + -32] ; get address of 'start'
    mov r10, QWORD [rbp + 16]
    mov QWORD [rbx], r10
    
    ; while (true)
    L_loop0:
    mov rbx, 1
    cmp rbx, 0
    je L_exit0
        ; if (*arg == ')
        mov rbx, QWORD [rbp + 16]
        movzx rbx, BYTE [rbx]
        mov r10, 0
        cmp rbx, r10
        sete bl
        and bl, 1
        movzx rbx, bl
        cmp rbx, 0
        je L_exit1
            ; break
            jmp L_exit0
            
        L_exit1:
        
        ; if (*arg == ' ')
        mov rbx, QWORD [rbp + 16]
        movzx rbx, BYTE [rbx]
        mov r10, 32
        cmp rbx, r10
        sete bl
        and bl, 1
        movzx rbx, bl
        cmp rbx, 0
        je L_exit2
            ; let length: u64; length = arg - start;
            mov rbx, QWORD [rbp + 16]
            mov r10, QWORD [rbp + -32]
            sub rbx, r10
            lea r10, QWORD [rbp + -24] ; get address of 'length'
            mov QWORD [r10], rbx
            
            ; if (length > 0)
            mov rbx, QWORD [rbp + -24]
            mov r10, 0
            cmp rbx, r10
            setg bl
            and bl, 1
            movzx rbx, bl
            cmp rbx, 0
            je L_exit3
                ; let bytes_written: i32;
                mov DWORD [rbp + -16], 0 ; zero initialize 'bytes_written'
                
                ; WriteFile(std_handle, start, length, &bytes_written, 0)
                sub rsp, 48 ; reserve shadow space and 5 arguments
                mov rbx, QWORD [rbp + -48]
                mov rcx, rbx ; arg 1
                mov rbx, QWORD [rbp + -32]
                mov rdx, rbx ; arg 2
                mov rbx, QWORD [rbp + -24]
                mov r8, rbx ; arg 3
                lea rbx, QWORD [rbp + -16] ; get address of 'bytes_written'
                mov r9, rbx ; arg 4
                mov rbx, 0
                mov DWORD [rsp + 32], ebx ; arg 5
                call WriteFile
                add rsp, 48 ; pop arguments
                mov rbx, rax ; get return value
                
                ; WriteFile(std_handle, "\n", 1, &bytes_written, 0)
                sub rsp, 48 ; reserve shadow space and 5 arguments
                mov rbx, QWORD [rbp + -48]
                mov rcx, rbx ; arg 1
                lea rbx, [REL lit_str_1]
                mov rdx, rbx ; arg 2
                mov rbx, 1
                mov r8, rbx ; arg 3
                lea rbx, QWORD [rbp + -16] ; get address of 'bytes_written'
                mov r9, rbx ; arg 4
                mov rbx, 0
                mov DWORD [rsp + 32], ebx ; arg 5
                call WriteFile
                add rsp, 48 ; pop arguments
                mov rbx, rax ; get return value
                
                ; arg_count++
                lea rbx, QWORD [rbp + -40] ; get address of 'arg_count'
                mov r10, rbx
                mov ebx, DWORD [rbx]
                mov r11, rbx
                inc r11
                mov DWORD [r10], r11d
                
            L_exit3:
            
            ; start = arg + 1
            mov rbx, QWORD [rbp + 16]
            mov r10, 1
            add rbx, r10
            lea r10, QWORD [rbp + -32] ; get address of 'start'
            mov QWORD [r10], rbx
            
        L_exit2:
        
        ; arg++
        lea rbx, QWORD [rbp + 16] ; get address of 'arg'
        mov r10, rbx
        mov rbx, QWORD [rbx]
        mov r11, rbx
        inc r11
        mov QWORD [r10], r11
        
    jmp L_loop0
    L_exit0:
    
    ; return arg_count
    mov ebx, DWORD [rbp + -40]
    mov rax, rbx ; return via rax
    jmp L_function_main_exit
    
    xor rax, rax ; Default return value 0
    L_function_main_exit:
    mov rsp, rbp
    pop rbp
    ret
    


section .data
STD_OUTPUT_HANDLE dq -11
lit_str_1 db "", 0Ah, "", 0
